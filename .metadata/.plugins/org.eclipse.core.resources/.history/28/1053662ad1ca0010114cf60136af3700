/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "string.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
typedef struct
{
	uint8_t buffer[BUFFER_SIZE];
	volatile uint16_t head;
	volatile uint16_t tail;
} RingBuffer;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define BUFFER_SIZE 512
#define MAX_DATA_LENGTH 512
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;

RTC_HandleTypeDef hrtc;

SPI_HandleTypeDef hspi1;
SPI_HandleTypeDef hspi3;
SPI_HandleTypeDef hspi5;

TIM_HandleTypeDef htim10;

UART_HandleTypeDef huart1;
UART_HandleTypeDef huart2;

/* USER CODE BEGIN PV */
uint8_t rxBuffer[100];  // Buffer to store the response from SIM800
uint8_t tmpBuffer[1];
char apn[30] = "airtelgprs.com";
char googleScriptURL[] = "https://script.google.com/macros/s/AKfycbwugUbdI2EMUUCwi5vUJj7T5JjdMl0K4yWs62IqT8ChuJj06nyqLLvcs_AFWEdh3Qi2/exec";
char commandBuffer[200];
float sensor_vals[26];
volatile uint8_t sendDataFlag = 0;
uint8_t sample_count = 10;
const float current_sensitivity = 0.185f, offset = 2.5f, vRef=3.3f, voltage_scale = 101.0f, resolution=64.0f;
uint32_t adc_voltage = 0, adc_current=0;

RingBuffer uart_rx_buffer;  // Create a ring buffer for UART1 reception
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_SPI1_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_SPI3_Init(void);
static void MX_SPI5_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_TIM10_Init(void);
static void MX_RTC_Init(void);
static void MX_ADC1_Init(void);
/* USER CODE BEGIN PFP */
void process_uart_data(void);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void GSM_Init(void)
{
	send_AT_command("AT");
	send_AT_command("AT+CSQ");
	send_AT_command("AT+CMEE=1");
	send_AT_command("AT+CREG?");
//	send_AT_command("AT+CGDCONT=1,\"IP\",\"airtelgprs.com\"");
//	send_AT_command("AT+CGACT=1,2");
	send_AT_command("AT+CGATT=1");

	snprintf(commandBuffer, sizeof(commandBuffer), "AT+SAPBR=3,1,\"APN\",\"%s\"", apn);
	send_AT_command(commandBuffer);

	send_AT_command("AT+SAPBR=1,1");
	send_AT_command("AT+SAPBR=2,1");
}

void setDemuxSelect(uint8_t channel)
{
    // PC13 is the least significant bit, PC14 is the middle bit, PC15 is the most significant bit
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, (channel & 0x01) ? GPIO_PIN_SET : GPIO_PIN_RESET);
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, (channel & 0x02) ? GPIO_PIN_SET : GPIO_PIN_RESET);
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_15, (channel & 0x04) ? GPIO_PIN_SET : GPIO_PIN_RESET);
}

// Function to enable or disable the demux (PB7)
void setDemuxEnable(uint8_t demux_num)
{
    if(demux_num==1)
    {
    	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10, GPIO_PIN_RESET);  // Active-low enable
    	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9, GPIO_PIN_SET);
    	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_SET);

    }
    else if(demux_num==2)
   {
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10, GPIO_PIN_SET);  // Active-low enable
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9, GPIO_PIN_SET);
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_RESET);
   }
    else if(demux_num==3)
    {
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10, GPIO_PIN_SET);  // Active-low enable
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9, GPIO_PIN_RESET);
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_SET);
    }
}

// Function to read 16-bit data from the MAX6675 sensor via SPI1
uint16_t readMAX6675(uint8_t demux_val)
{
    uint16_t rawData = 0;

    if(demux_val == 1)
    {
		// Start SPI transaction on SPI Channel 1 (MAX6675 uses SPI Mode 1)
		HAL_SPI_Receive(&hspi1, (uint8_t*)&rawData, 1, HAL_MAX_DELAY);
    }
    else if(demux_val == 2)
	{
		// Start SPI transaction on SPI Channel 2 (MAX6675 uses SPI Mode 1)
		HAL_SPI_Receive(&hspi5, (uint8_t*)&rawData, 1, HAL_MAX_DELAY);
	}
    else if(demux_val == 3)
	{
		// Start SPI transaction on SPI Channel 3 (MAX6675 uses SPI Mode 1)
		HAL_SPI_Receive(&hspi3, (uint8_t*)&rawData, 1, HAL_MAX_DELAY);

	}

    return rawData;
}

// Function to convert raw MAX6675 data to temperature (Celsius)
float convertToTemperature(uint16_t rawData)
{
    if (rawData & 0x0004)  // Check if thermocouple is disconnected
    {
        return 0.0;  // Return NaN if the thermocouple is disconnected
    }
    rawData >>= 3;  // Shift to remove lower 3 status bits
    return rawData * 0.25;  // MAX6675 resolution is 0.25Â°C per bit
}

//Functions to read Voltage and Current Analog Values
void readADCValues(void)
{
	HAL_ADC_Start(&hadc1);

	/* Poll for conversion completion */
	if (HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY) == HAL_OK)
		adc_voltage = HAL_ADC_GetValue(&hadc1);	//Get ADC value for Channel 4 (Voltage)
	HAL_ADC_Stop(&hadc1);

	// Read Channel 9 (Current)
	HAL_ADC_Start(&hadc1); // Restart ADC for Channel 9
	/* Poll for second conversion (Channel 9, Current) */
	if (HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY) == HAL_OK)
		adc_current = HAL_ADC_GetValue(&hadc1); /* Get ADC value for Channel 9 (Current) */

	/* Stop ADC */
	HAL_ADC_Stop(&hadc1);
}

// Function to send AT command via UART1
void send_AT_command(char *command)
{
    HAL_UART_Transmit(&huart1, (uint8_t *)command, strlen(command), 5000);  // Send the command over UART1
    HAL_Delay(500);
    HAL_UART_Transmit(&huart1, (uint8_t *)"\r\n", 2, 5000);  // Send carriage return and line feed (CRLF)
//    // Send the command to UART2 (to Arduino, so you can monitor it)
//	HAL_UART_Transmit(&huart2, (uint8_t *)"Sent to GSM: ", 13, 1000);  // Prefix to indicate sending
//	HAL_UART_Transmit(&huart2, (uint8_t *)command, strlen(command), 2000);  // Echo the AT command
//	HAL_UART_Transmit(&huart2, (uint8_t *)"\r\n", 2, 1000);  // Send CRLF after the command to Arduino

	HAL_Delay(3000);
	if (strstr(command, "HTTPACTION=1") != NULL)  // strstr() checks for the substring
		HAL_Delay(10000);  // Delay for 10,000 ms (10 seconds)

	 process_uart_data();
	 HAL_Delay(200);
}


// Add a byte to the ring buffer
void ring_buffer_put(RingBuffer *rb, uint8_t data)
{
    uint16_t next = (rb->head + 1) % BUFFER_SIZE;

    if (next != rb->tail)  // If the buffer is not full, add data
    {
        rb->buffer[rb->head] = data;
        rb->head = next;
    }
}

// Get a byte from the ring buffer
uint8_t ring_buffer_get(RingBuffer *rb)
{
    if (rb->head == rb->tail)  // If buffer is empty, return 0
    {
        return 0;
    }

    uint8_t data = rb->buffer[rb->tail];
    rb->tail = (rb->tail + 1) % BUFFER_SIZE;
    return data;
}

// Check if the buffer is empty
int ring_buffer_is_empty(RingBuffer *rb)
{
    return rb->head == rb->tail;
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart == &huart1)  // If the interrupt is from UART1
    {
//        uint8_t received_byte;
        ring_buffer_put(&uart_rx_buffer, tmpBuffer[0]);  // Store the byte in the ring buffer

        HAL_UART_Receive_IT(&huart1, tmpBuffer, 1);  // Enable interrupt for next byte
    }
}

void process_uart_data(void)
{
    static char rx_line[300];  // Buffer to store a line of response
    static uint16_t line_index = 0;


    // Check if there is data in the ring buffer
    while (!ring_buffer_is_empty(&uart_rx_buffer))
    {
        uint8_t byte = ring_buffer_get(&uart_rx_buffer);

        if (byte == '\n' || byte == '\r')  // End of line
        {
            rx_line[line_index] = '\0';  // Null-terminate the line
            line_index = 0;

            // Process the response (e.g., check if it's "OK" or "ERROR")
            if (strcmp(rx_line, "OK") == 0)
            {
                HAL_UART_Transmit(&huart2, (uint8_t *)"Received OK\r\n", 14, 1000);
            }
            else if (strcmp(rx_line, "ERROR") == 0)
            {
                HAL_UART_Transmit(&huart2, (uint8_t *)"Received ERROR\r\n", 17, 1000);
            }
            else
            {
                // Optionally transmit the full response to UART2 for debugging
                HAL_UART_Transmit(&huart2, (uint8_t *)"Response: ", 10, 1000);
                HAL_UART_Transmit(&huart2, (uint8_t *)rx_line, strlen(rx_line), 1000);
                HAL_UART_Transmit(&huart2, (uint8_t *)"\r\n", 2, 1000);
            }
        }
        else
        {
            if (line_index < sizeof(rx_line) - 1)
            {
                rx_line[line_index++] = byte;  // Accumulate characters
            }
        }
    }
}

void sendDataToGoogleSheet(void)
{
	char data[MAX_DATA_LENGTH];
	char tempBuffer[10];
	// Start with "C=" and "V="
	snprintf(data, MAX_DATA_LENGTH, "C=%.2f&V=%.2f", sensor_vals[24], sensor_vals[25]);

	// Loop through the 24 sensors
	for (int i = 0; i < 24; i++) {
		snprintf(tempBuffer, sizeof(tempBuffer), "&S%d=%.2f", (i+1), sensor_vals[i]);  // Create the "Sx=value" part
		strcat(data, tempBuffer);  // Append to the main data string
	}

//	char firstData[150];
//	char secondData[150];
//	char thirdData[150];

	// Find index of "S7=" and "S16="
//	char *s12_index = strstr(data, "S12=");
//	char *s16_index = strstr(data, "S16=");

	send_AT_command("AT+HTTPINIT");
	send_AT_command("AT+HTTPPARA=\"CID\",1");
	send_AT_command("AT+HTTPSSL=1");

	snprintf(commandBuffer, sizeof(commandBuffer), "AT+HTTPPARA=\"URL\",\"%s\"", googleScriptURL);
	send_AT_command(commandBuffer);
	HAL_Delay(1000);

	send_AT_command("AT+HTTPPARA=\"CONTENT\",\"application/x-www-form-urlencoded\"");

//	int firstDataLength = s12_index - data - 1;
//	strncpy(firstData, data, firstDataLength);
//	firstData[firstDataLength] = '\0';  // Null-terminate the string
//
//	// Send first part
	char command[150];
//	snprintf(command, sizeof(command), "AT+HTTPDATA=%d,20000", strlen(firstData));
//	send_AT_command(command);
//	send_AT_command(firstData);
//	send_AT_command("AT+HTTPACTION=1");
//	HAL_Delay(2000);

	// Split data into second part (between "S7=" and "S16=")
//	int secondDataLength = s16_index - s7_index - 1;
//	strncpy(secondData, s7_index, secondDataLength);
//	secondData[secondDataLength] = '\0';  // Null-terminate the string
//
//	// Send second part
//	snprintf(command, sizeof(command), "AT+HTTPDATA=%d,15000", strlen(secondData));
//	send_AT_command(command);
//	send_AT_command(secondData);
//	send_AT_command("AT+HTTPACTION=1");
//	HAL_Delay(1000);

	// Split data into third part (from "S16=" onwards)
//	strcpy(thirdData, s12_index);  // Copy everything from "S16=" to the end

	// Send third part
	snprintf(command, sizeof(command), "AT+HTTPDATA=%d,30000", strlen(data));
	send_AT_command(command);
	send_AT_command(data);
	send_AT_command("AT+HTTPACTION=1");
	HAL_Delay(5000);

	send_AT_command("AT+HTTPTERM");
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM10) {
        // Your code when the timer reaches 2 minutes
    	sendDataFlag = 1;
    }
}


/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_SPI1_Init();
  MX_USART2_UART_Init();
  MX_SPI3_Init();
  MX_SPI5_Init();
  MX_USART1_UART_Init();
  MX_TIM10_Init();
  MX_RTC_Init();
  MX_ADC1_Init();
  /* USER CODE BEGIN 2 */

  for(int i = 0; i<26; i++)
	  sensor_vals[i] = 0.0;

  HAL_UART_Receive_IT(&huart1, tmpBuffer, 1);  // Start UART reception in interrupt mode
  HAL_TIM_Base_Start_IT(&htim10);  // Start Timer10 in interrupt mode

//  GSM_Init();
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	  readADCValues();
	  uint32_t currentReading = adc_current;
	  float currentVoltage = adc_current*vRef/resolution;
	  float current = (currentVoltage - offset)/current_sensitivity;

	  uint32_t voltageReading = adc_voltage;
//	  float voltage = voltageReading*(vRef/resolution)*voltage_scale;
	  float voltage = voltageReading*(vRef/resolution);

	  sensor_vals[24] = current;
	  sensor_vals[25] = voltage;

	  for(uint8_t demux = 1; demux<=3; demux+=1)
	  {
		  setDemuxEnable(demux);
		  HAL_Delay(200);

		  float temporary_vals[8] = {0,0,0,0,0,0,0,0};

		  for(uint8_t cycle=1; cycle<=sample_count; cycle++)
		  {
		  	  for (uint8_t channel = 0; channel < 8; channel++)
	          {
	              // Set the demux select lines for the current channel
	              setDemuxSelect(channel);
	              HAL_Delay(100);

	              // Read the 16-bit sensor data from the MAX6675 via SPI
	              uint16_t rawData = readMAX6675(demux);
	              // Convert the raw data to temperature in Celsius
	              float temperature = convertToTemperature(rawData);
	              temporary_vals[channel]+=temperature;

	              // Small delay between sensor reads
//	              HAL_Delay(200);  // Adjust as needed
	          }
		  }

		  for(uint8_t channel = 0; channel<8; channel++)
			  sensor_vals[((demux-1)*8) + channel] = temporary_vals[channel]/sample_count;

		  if(sendDataFlag)
			  break;
	  }

	  if(sendDataFlag)
	  {
//		  sendDataToGoogleSheet();
		  sendDataFlag = 0;
	  }


    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};

  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */

  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
  */
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV2;
  hadc1.Init.Resolution = ADC_RESOLUTION_6B;
  hadc1.Init.ScanConvMode = ENABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 2;
  hadc1.Init.DMAContinuousRequests = DISABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
  */
  sConfig.Channel = ADC_CHANNEL_4;
  sConfig.Rank = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_15CYCLES;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
  */
  sConfig.Channel = ADC_CHANNEL_9;
  sConfig.Rank = 2;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}

/**
  * @brief RTC Initialization Function
  * @param None
  * @retval None
  */
static void MX_RTC_Init(void)
{

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_TimeTypeDef sTime = {0};
  RTC_DateTypeDef sDate = {0};

  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */

  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
  hrtc.Init.AsynchPrediv = 127;
  hrtc.Init.SynchPrediv = 255;
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
  {
    Error_Handler();
  }

  /* USER CODE BEGIN Check_RTC_BKUP */

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  sTime.Hours = 0x0;
  sTime.Minutes = 0x0;
  sTime.Seconds = 0x0;
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
  {
    Error_Handler();
  }
  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
  sDate.Month = RTC_MONTH_JANUARY;
  sDate.Date = 0x1;
  sDate.Year = 0x0;

  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}

/**
  * @brief SPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI1_Init(void)
{

  /* USER CODE BEGIN SPI1_Init 0 */

  /* USER CODE END SPI1_Init 0 */

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_16BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}

/**
  * @brief SPI3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI3_Init(void)
{

  /* USER CODE BEGIN SPI3_Init 0 */

  /* USER CODE END SPI3_Init 0 */

  /* USER CODE BEGIN SPI3_Init 1 */

  /* USER CODE END SPI3_Init 1 */
  /* SPI3 parameter configuration*/
  hspi3.Instance = SPI3;
  hspi3.Init.Mode = SPI_MODE_MASTER;
  hspi3.Init.Direction = SPI_DIRECTION_2LINES;
  hspi3.Init.DataSize = SPI_DATASIZE_16BIT;
  hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi3.Init.NSS = SPI_NSS_SOFT;
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi3.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI3_Init 2 */

  /* USER CODE END SPI3_Init 2 */

}

/**
  * @brief SPI5 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI5_Init(void)
{

  /* USER CODE BEGIN SPI5_Init 0 */

  /* USER CODE END SPI5_Init 0 */

  /* USER CODE BEGIN SPI5_Init 1 */

  /* USER CODE END SPI5_Init 1 */
  /* SPI5 parameter configuration*/
  hspi5.Instance = SPI5;
  hspi5.Init.Mode = SPI_MODE_MASTER;
  hspi5.Init.Direction = SPI_DIRECTION_2LINES;
  hspi5.Init.DataSize = SPI_DATASIZE_16BIT;
  hspi5.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi5.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi5.Init.NSS = SPI_NSS_SOFT;
  hspi5.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
  hspi5.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi5.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi5.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi5.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi5) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI5_Init 2 */

  /* USER CODE END SPI5_Init 2 */

}

/**
  * @brief TIM10 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM10_Init(void)
{

  /* USER CODE BEGIN TIM10_Init 0 */

  /* USER CODE END TIM10_Init 0 */

  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM10_Init 1 */

  /* USER CODE END TIM10_Init 1 */
  htim10.Instance = TIM10;
  htim10.Init.Prescaler = 31999;
  htim10.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim10.Init.Period = 60000;
  htim10.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim10.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim10) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_OC_Init(&htim10) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_TIMING;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_OC_ConfigChannel(&htim10, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM10_Init 2 */

  /* USER CODE END TIM10_Init 2 */

}

/**
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{

  /* USER CODE BEGIN USART1_Init 0 */

  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 9600;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}

/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 9600;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10|GPIO_PIN_8|GPIO_PIN_9, GPIO_PIN_RESET);

  /*Configure GPIO pins : PC13 PC14 PC15 */
  GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pins : PB10 PB8 PB9 */
  GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_8|GPIO_PIN_9;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */


/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
